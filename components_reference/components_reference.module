<?php

/**
 * @file
 * Defines a field type for referencing a component from another entity.
 * 
 * This module is based on the Node Reference module (part of the References module):
 * @link http://drupal.org/project/references
 */

/**
 * Implements hook_help().
 */
function components_reference_help($path, $arg) {
  switch ($path) {
    case 'admin/help#components-reference':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Components Reference module provides a field to which a component can be attached.') . '</p>';
      return $output;
      break;
  }
}

/************************/
/* Field Type API hooks */
/************************/

/**
 * Implements hook_field_info().
 */
function components_reference_field_info() {
  return array(
    'component_reference' => array(
      'label' => t('Component reference'),
      'description' => t('This field stores the ID of a related component.'),
      'settings' => array( // instance_settings
        'referenceable_types' => array(),
      ),
      //'settings' => array(),
      'default_widget' => 'component_reference_cid',
      'default_formatter' => 'component_reference_component',
      // Add entity property info
      'property_type' => 'component',
    ),
  );
}

/**
 * Implements hook_field_settings_form().
 */
function components_reference_field_settings_form($field, $instance, $has_data) {
  //$settings = $instance['settings'];
  $settings = $field['settings'];
  
  $form = array();
  $form['referenceable_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Component types that can be referenced'),
    '#multiple' => TRUE,
    '#default_value' => $settings['referenceable_types'],
    '#options' => components_get_types_names(),
  );
  
  return $form;
}

/**
 * Implements hook_field_validate().
 */
function components_reference_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, $errors) {
  foreach ($items as $delta => $item) {
    if (!empty($item['cid']) && !is_numeric($item['cid'])) {
      $errors[$field['type']][$langcode][$delta][] = array(
        'error' => 'component_reference_cid_invalid',
        'message' => t('%label: invalid input.', array('%label' => $instance['label'])),
      );
    }
  }
}

/**
 * Implements hook_field_is_empty().
 */
function components_reference_field_is_empty($item, $field) {
  if (!empty($item['cid'])) {
    return FALSE;
  }
  elseif (isset($item['entity'])) {
    return components_reference_component_is_empty($item['entity']);
  }
  return TRUE;
}

/**
 * Determines whether a component entity is empty based on the fields.
 * 
 * @param Component $component
 */
function components_reference_component_is_empty(Component $component) {
  $instances = field_info_instances('component', $component->type);
  
  foreach ($instances as $instance) {
    $field_name = $instance['field_name'];
    $field = field_info_field($field_name);
    
    // Determine the list of languages to iterate on.
    $languages = field_available_languages('component', $field);
    
    foreach ($languages as $langcode) {
      if (!empty($item->$field_name[$langcode])) {
        // If at least one field is not empty; the component is not empty.
        foreach ($item->$field_name[$langcode] as $field_item) {
          if (!module_invoke($field['module'], 'field_is_empty', $field_item, $field)) {
            return FALSE;
          }
        }
      }
    }
  }
  return TRUE;
}

/**
 * Implements hook_field_presave().
 */
function components_reference_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  foreach ($items as &$item) {
    // In case the entity has been loaded / created, save it and set the id.
    if (isset($item['entity'])) {
      $item['entity']->save(TRUE);
      $item = array('cid' => $item['entity']->cid);
    }
  }
}

/*****************************/
/* Field Type API: Formatter */
/*****************************/

/**
 * Implements hook_field_formatter_info().
 */
function components_reference_field_formatter_info() {
  return array(
    'component_reference_component' => array(
      'label' => t('Rendered component'),
      'description' => t('Display the referenced component in a specific view mode'),
      'field types' => array('component_reference'),
      'settings' => array(
      	'component_reference_view_mode' => 'full',
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function components_reference_field_formatter_settings_form($field, $instance, $view_mode, $form, $form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  //$settings = $display['instance_settings'];
  //$settings = $instance['settings'];
  
  // Only build this information for component_reference_component displays
  if ($display['type'] !== 'component_reference_component') {
    return NULL;
  }
  
  $entity_info = entity_get_info('component');
  $view_modes = $entity_info['view modes'];
  $options = array();
  
  foreach ($view_modes as $name => $mode) {
    $options[$name] = $mode['label'];
  }
  
  $element['component_reference_view_mode'] = array(
    '#title' => t('View mode'),
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => $settings['component_reference_view_mode'],
    // Never empty, so no #empty_option
  );
  
  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function components_reference_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  //$settings = $display['instance_settings'];
  //$settings = $instance['settings'];
  
  if ($display['type'] === 'component_reference_component') {
    $entity_info = entity_get_info('component');
    $view_modes = $entity_info['view modes'];
    $mode = $view_modes[$settings['component_reference_view_mode']]['label'];
    $summary = t('View mode: %view_mode', array('%view_mode' => $mode));
  }
  else {
    $summary = NULL;
  }
  return $summary;
}

/**
 * Implements hook_field_formatter_view().
 */
function components_reference_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $result = array();
  $settings = $display['settings'];
  //$settings = $display['instance_settings'];
  //$settings = $instance['settings'];
  
  switch ($display['type']) {
    case 'component_reference_component':
      $view_mode = $settings['component_reference_view_mode'];
      foreach ($items as $delta => $item) {
        // @TODO: drupal_render, is this a best practice?
        $result[$delta]['#markup'] = drupal_render(component_view(component_load($item['cid'])));
      }
      break;
  }
  
  return $result;
}

/**************************/
/* Field Type API: Widget */
/**************************/

/**
 * Implements hook_field_widget_info().
 */
function components_reference_field_widget_info() {
  return array(
    'component_reference_cid' => array(
      'label' => t('Component ID'),
      'field types' => array('component_reference'),
    ),
    'component_reference_embed' => array(
      'label' => t('Component Embedded'),
      'field types' => array('component_reference'),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 */
function components_reference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $base = $element;
  
  switch ($instance['widget']['type']) {
    case 'component_reference_cid':
      $element['cid'] = array(
        '#type' => 'textfield',
        '#title' => t('Component ID'),
        '#default_value' => isset($items[$delta]['cid']) ? $items[$delta]['cid'] : NULL,
      ) + $base;
      break;
    case 'component_reference_embed':
      $field_parents = $element['#field_parents'];
      $field_name = $element['#field_name'];
      $language = $element['#language'];
      
      // @TODO remove hardcoded type, provide option of field refereceable types
      $component_type = 'header'; // HARDCODED
      
      $component = components_reference_field_get_entity($item[$delta], $component_type);
      
      // Nest the component entity form in a dedicated parent space,
      // by appending [field_name, langcode, delta] to the current parent space.
      // That way the form values of the component item are separated.
      $parents = array_merge($field_parents, array($field_name, $language, $delta));
      
      $element += array(
        '#element_validate' => array('components_reference_field_widget_embed_validate'),
        '#parents' => $parents,
      );
      
      // Put our entity in the form state, so FAPI callbacks can access it.
      $field_state = field_form_get_state($field_parents, $field_name, $language, $form_state);
      $field_state['entity'][$delta] = $component;
      field_form_set_state($field_parents, $field_name, $language, $form_state, $field_state);
      
      field_attach_form('component', $component, $element, $form_state, $language);
      
      if (empty($element['#required'])) {
        $element['#after_build'][] = 'components_reference_field_widget_embed_delay_required_validation';
      }
      
      break;
  }
  
  return $element;
}

/**
 * FAPI #after_build of an individual component element to delay the validation of #required.
 */
function components_reference_field_widget_embed_delay_required_validation(&$element, &$form_state) {
  // If the process_input flag is set, the form and its input is going to be
  // validated. Prevent #required (sub)fields from throwing errors while
  // their non-#required component item is empty.
  if ($form_state['process_input']) {
    _components_reference_collect_required_elements($element, $element['#component_reference_required_elements']);
  }
  return $element;
}

function _components_reference_collect_required_elements(&$element, &$required_elements) {
  // Recurse through all children.
  foreach (element_children($element) as $key) {
    if (isset($element[$key]) && $element[$key]) {
      _components_reference_collect_required_elements($element[$key], $required_elements);
    }
  }
  if (!empty($element['#required'])) {
    $element['#required'] = FALSE;
    $required_elements[] = &$element;
    $element += array('#pre_render' => array());
    array_unshift($element['#pre_render'], 'components_reference_field_widget_render_required');
  }
}

/**
 * #pre_render callback that ensures the element is rendered as being required.
 */
function components_reference_field_widget_render_required($element) {
  $element['#required'] = TRUE;
  return $element;
}

/**
 * FAPI validation of an individual field-collection element.
 */
function components_reference_field_widget_embed_validate($element, &$form_state, $complete_form) {
  $instance = field_widget_instance($element, $form_state);
  $field = field_widget_field($element, $form_state);
  $field_parents = $element['#field_parents'];
  $field_name = $element['#field_name'];
  $language = $element['#language'];

  $field_state = field_form_get_state($field_parents, $field_name, $language, $form_state);
  $component = $field_state['entity'][$element['#delta']];
  
  // Attach field API validation of the embedded form.
  field_attach_form_validate('component', $component, $element, $form_state);
  
  // Now validate required elements if the entity is not empty.
  if (!components_reference_component_is_empty($component) && !empty($element['#component_reference_required_elements'])) {
    foreach ($element['#component_reference_required_elements'] as &$elements) {
      
      // Copied from _form_validate().
      if (isset($elements['#needs_validation'])) {
        $is_empty_multiple = (!count($elements['#value']));
        $is_empty_string = (is_string($elements['#value']) && drupal_strlen(trim($elements['#value'])) == 0);
        $is_empty_value = ($elements['#value'] === 0);
        if ($is_empty_multiple || $is_empty_string || $is_empty_value) {
          if (isset($elements['#title'])) {
            form_error($elements, t('!name field is required.', array('!name' => $elements['#title'])));
          }
          else {
            form_error($elements);
          }
        }
      }
    }
  }

  // Only if the form is being submitted, finish the collection entity and
  // prepare it for saving.
  if ($form_state['submitted'] && !form_get_errors()) {

    field_attach_submit('component', $component, $element, $form_state);
    // Put the component item in $item['entity'], so it is saved with
    // the host entity via hook_field_presave() / field API if it is not empty.
    // @see components_reference_field_presave()
    $item['entity'] = $component;
    form_set_value($element, $item, $form_state);
  }
}

/**
 * Implements hook_field_widget_error().
 */
function components_reference_field_widget_error($element, $error, $form, $form_state) {
  switch ($error['error']) {
    case 'component_reference_cid_invalid':
      $error_element = $element;
      break;
    default:
      $error_element = $element;
      break;
  }
  form_error($error_element, $error['message']);
}

/**
 * Gets a component
 * 
 * @return
 *   A component object or FALSE.
 */
function components_reference_field_get_entity(&$item, $component_type = NULL) {
  if (isset($item['cid'])) {
    return component_load($item['cid']);
  }
  elseif (!isset($item['entity']) && isset($component_type)) {
    $item['entity'] = component_create(array('type' => $component_type));
  }
  return isset($item['entity']) ? $item['entity'] : FALSE;
}

/*********/
/* OTHER */
/*********/

/**
 * Implements hook_form_FORM_ID_alter().
 */
function components_reference_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  if ($form['#field']['type'] == 'component_reference') {
    // Set the cardinality of the field settings to UNLIMITED by default.
    $form['field']['cardinality']['#default_value'] = FIELD_CARDINALITY_UNLIMITED;
  }
}
